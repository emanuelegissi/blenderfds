"""BlenderFDS, interface types"""

import bpy, sys, time
from blenderfds.types.results import BFResult, BFException
from blenderfds.types.collections import BFList, BFAutoItem
from blenderfds.types.flags import *
from blenderfds.lib import geometry, fds_surf, fds_to_py, fds_format
from blenderfds.lib.utilities import isiterable
from blenderfds.config import *

### BFCommon

class BFCommon(BFAutoItem):
    """Common attributes and methods for all BF classes.
    
    idname -- Instance unique identificator. Type: string, never None. Eg: "bf_fyi"
    label -- UI label. Type: string, if None idname is used. Eg: "FYI"
    description -- UI help text. Type: string, None. Eg: "For your information"
    enum_id -- Instance unique numeric id for EnumProperty item. Type: int, never None. Eg: "1023"    
    flags -- define specific behaviours, see types.flags. Eg: NOUI | NOEXPORT
    fds_label -- FDS label. Type: string, if None this is a custom property. Eg: "ID"
    bf_props -- List of related BFProp idnames. Type: tuple of strings, None.
    bf_prop_export -- idname of related export BFProp. Type: string, None. Eg: "bf_fyi_export"
    bf_prop_custom -- idname of related custom BFProp. Type: string, None. Eg: "bf_fyi_custom"
    bf_other -- Other optional BlenderFDS parameters. Type: dict, None. Eg: "{'prop1': value1, 'prop2': value2}"
    bpy_type -- Blender type of self. Eg: bpy.types.Scene, bpy.types.Object, bpy.types.Material
    bpy_idname -- idname of related Blender property. Type: string, None. Eg: "bf_fyi" or "name".
    bpy_prop -- Blender property type. Type: bpy.props.*Property, if None refer to existing Blender property.
    **kwargs -- Other optional Blender property parameters. Eg: default = "NONE".
    """
    bf_list = BFList() # contains all instances of this class

    def __init__(self, idname, label=None, description=None, enum_id=0, flags=0, \
        fds_label=None, bf_props=None, bf_prop_export=None, bf_prop_custom=None, bf_other=None, \
        bpy_type=None, bpy_idname=None, bpy_prop=None, **kwargs):
        # Check enum_id unicity
        if enum_id and enum_id in (item.enum_id for item in self.bf_list):
            raise ValueError("BFDS: Duplicated enum_id '{}' in '{}' and '{}'".format(enum_id, item.idname, idname))
        # Parent class
        BFAutoItem.__init__(self, idname=idname)
        # Identification
        self.label = label or idname
        self.description = description
        self.enum_id = enum_id
        self.flags = flags
        # Others
        self.fds_label = fds_label
        self.bpy_type = bpy_type
        # Set related bf_props instances: transform BFList of idname in BFList of BFProp
        if bf_props: self.bf_props = BFProp.bf_list[bf_props]
        else: self.bf_props = None
        # Set export BFProp: transform idname in BFProp or create new BFProp
        if bf_prop_export:
            try: self.bf_prop_export = BFProp.bf_list[bf_prop_export] # Does it esist?
            except KeyError: # No, create a default one
                self.bf_prop_export = BFProp(
                    idname = bf_prop_export,
                    label = "Export",
                    description = "Export to FDS",
                    bpy_idname = bf_prop_export,
                    bpy_prop = bpy.props.BoolProperty,
                    default = False,
                    )
        else: self.bf_prop_export = None
        # Set custom BFProp: transform idname in BFProp, do not create default it shall exist
        if bf_prop_custom: self.bf_prop_custom = BFProp.bf_list[bf_prop_custom]
        else: self.bf_prop_custom = None
        # Set bf_other
        self.bf_other = bf_other
        # Set related Blender property
        self.bpy_idname = bpy_idname
        self.bpy_prop = bpy_prop
        self.bpy_other = kwargs

    # Register/Unregister (me, each from self.bf_props, self.bf_prop_export, self.bf_prop_custom)

    def register(self, bpy_type=None):
        """Register all related Blender properties."""
        # Get bpy_type: mine or that sent as parameter from caller object
        if not bpy_type: bpy_type = self.bpy_type
        # Register children, export and custom
        for child in self.children: child.register(bpy_type)
        if self.bf_prop_export: self.bf_prop_export.register(bpy_type)
        if self.bf_prop_custom: self.bf_prop_custom.register(bpy_type)
        # Register my own Blender property
        if self.bpy_prop and self.bpy_idname:
            if DEBUG: print("BFDS: BFCommon.register:", bpy_type, self.bpy_idname) 
            setattr(bpy_type, self.bpy_idname, \
                self.bpy_prop(name=self.label, description=self.description, **self.bpy_other))

    def unregister(self, bpy_type=None):
        """Unregister all related Blender properties."""
        # Get bpy_type: mine or that sent as parameter from caller object
        if not bpy_type: bpy_type = self.bpy_type
        # Unregister children, export and custom
        for child in self.children: child.unregister(bpy_type)
        if self.bf_prop_export: self.bf_prop_export.unregister(bpy_type)
        if self.bf_prop_custom: self.bf_prop_custom.unregister(bpy_type)
        # and unregister my own Blender property
        if self.bpy_idname:
            if DEBUG: print("BFDS: BFCommon.unregister:", bpy_type, self.bpy_idname) 
            try: delattr(bpy_type, self.bpy_idname)
            except: pass

    # UI
    
    def has_ui(self, context, element) -> "bool":
        """Return True if self has an user interface."""
        if self.flags & NOUI: return False
        return True

    def has_active_ui(self, context, element) -> "bool":
        """Return True if self has an active user interface."""
        if self.flags & ACTIVEUI: return True
        return self.get_exported(context, element) or False

    # Export

    def get_exported(self, context, element) -> "bool":
        """Return True if self is exported to FDS."""
        if self.flags & NOEXPORT: return False
        try: return self.bf_prop_export.get_value(context, element)
        except: return True

    def _get_children(self) -> "BFList of BFProps, never None":
        """Get my children, bf_prop_export is not a children."""
        children = BFList()
        if self.bf_props: children.extend(self.bf_props) # self.bf_props could be None
        if self.bf_prop_custom: children.append(self.bf_prop_custom) # self.bf_prop_custom could be None
        return children
    
    children = property(_get_children)

    def get_children_res(self, context, element, ui=False) -> "BFList of BFResult, never None":
        """Return a BFlist of children BFResult. On error raise joined BFException."""
        if DEBUG: print("BFDS: BFCommon.get_children_res:", self.idname) 
        # Init
        children_res, err_msgs = BFList(), list()
        # Get children res, manage exceptions
        for child in self.children:
            try: child_res = child.get_res(context, element, ui=False)
            except BFException as child_err:
                err_msgs.extend(child_err.labels) # The child sends exceptions, take note. Labels attach sender name to msgs.
            else:
                if child_res is None: continue # The child did not send a result, continue
                children_res.append(child_res) # The child result is appended to the BFList
        # Return
        if err_msgs: raise BFException(sender=self, msgs=err_msgs) # Raise all piled exceptions to parent
        return children_res

    def _format(self, context, element, my_res, children_res) -> "str or None":
        """Format to FDS notation. On error raise BFException."""
        # Expected output:
        #   ! Me: Message               < my_res.labels
        #   ! Me: Children1: Message    < body < children_res values
        #   Children1 body
        #   ! Me: Children2: Message
        #   Children2 body
        #   My value                    < my_res.value
        return "".join((
            fds_format.to_comment(my_res.labels),
            "".join(child_res.value or str() for child_res in children_res), # child_res.value could be None
            my_res.value or str(), # my_res.value could be None
        ))

    def get_my_res(self, context, element, ui=False) -> "BFResult or None":
        """Get my BFResult. On error raise BFException."""
        if DEBUG: print("BFDS: BFCommon.get_my_res:", self.idname)
        # Check me exported 
        if not self.get_exported(context, element): return None
        # Here you can set a value, append msgs, append relevant operators.
        # When something is not good you should raise a BFException.
        # When ui is calling, do not perform heavy or useless calculations.
        return BFResult(
            sender = self,
            value = DEBUG and "! Debug value from BFCommon.get_my_res of '{}'\n".format(self.idname) or None, 
            msg = DEBUG and "Debug message from BFCommon.get_my_res of '{}'".format(self.idname) or None, 
        )

    def get_res(self, context, element, ui=False) -> "BFResult or None":
        """Get full BFResult (children and mine). On error raise BFException."""
        if DEBUG: print("BFDS: BFCommon.get_res:", self.idname, element)
        # Init
        my_res = self.get_my_res(context, element, ui)
        if not my_res: return None
        children_res = self.get_children_res(context, element, ui)
        # Format value and return
        my_res.value = self._format(context, element, my_res, children_res)
        return my_res
   
    # Import

    def set_exported(self, context, element, value=True) -> "bool":
        """Set if self is exported to FDS."""
        if element and hasattr(self, "bf_prop_export") and self.bf_prop_export: self.bf_prop_export.set_value(context, element, value)

    # Other

    def _get_descendants(self) -> "Same as self.children":
        """Get my children and the children of my children..."""
        children = descendants = self.children # self.children is never None
        for child in children or list(): descendants.extend(child.descendants)
        return descendants
    
    descendants = property(_get_descendants)

    # Precision for float types
    
    def _get_precision(self) -> "int":
        """Get my precision for element or default to 2."""
        return self.bpy_other.get("precision", 2)

    precision = property(_get_precision)

    # Menu item for EnumProperty

    def _get_enumproperty_item(self) -> "tuple":
        """Get item for EnumProperty items."""
        if self.flags & NOUI: return None
        description = self.description and "{} ({})".format(self.label, self.description) or self.label
        return (self.idname, description, description, self.enum_id)

    enumproperty_item = property(_get_enumproperty_item)

### Blender property <-> BFProp <-> FDS parameter

class BFProp(BFCommon):
    """BlenderFDS property, interface between a Blender property and an FDS parameter. See BFCommon."""
    bf_list = BFList() # contains all instances of this class

    def __init__(self, idname, label=None, description=None, flags=0, \
        fds_label=None, bf_props=None, bf_prop_export=None, bf_other=None, \
        bpy_idname=None, bpy_prop=None, **kwargs):
        # Parent class, partially use its features
        BFCommon.__init__(self, idname=idname, label=label, description=description, flags=flags,\
            fds_label=fds_label, bf_props=bf_props, bf_prop_export=bf_prop_export, bf_other=bf_other, \
            bpy_idname=bpy_idname, bpy_prop=bpy_prop, **kwargs)

    # UI: draw panel (self.bf_prop_export, me)
    # Override methods for custom panel

    def _get_layout(self, context, element, layout) -> "layout":
        """If self has a bf_prop_export, prepare double-column Blender panel layout."""
        layout = layout.row()
        if self.bf_prop_export:
            # Set two distinct colums: layout_export and layout_ui
            layout_export, layout = layout.column(), layout.column()
            layout_export.prop(element, self.bf_prop_export.bpy_idname, text="")
        else:
            # Set one only column
            layout = layout.column()
        layout.active = bool(self.has_active_ui(context, element)) # bool( protects from None
        return layout

    def _draw_body(self, context, element, layout):
        """Draw my part of panel body."""
        if not self.bpy_idname: return
        row = layout.row()
        row.prop(element, self.bpy_idname, text=self.label)

    def _draw_extra(self, context, element, layout):
        """Draw extra customized widgets."""
        pass
    
    def _draw_messages(self, context, element, layout):
        """Draw messages and exceptions."""
        try: res = self.get_res(context, element, ui=True)
        except BFException as err: err.draw(layout)
        else: res and res.draw(layout) # check res and res.msgs existence before...    
        
    def draw(self, context, element, layout):
        """Draw my part of Blender panel."""
        if self.has_ui(context, element):
            layout = self._get_layout(context, element, layout)
            self._draw_body(context, element, layout)
            self._draw_extra(context, element, layout)
            self._draw_messages(context, element, layout)

    # Export (only me, not self.bf_props)
    # get_my_res and get_children_res are not used
    
    # Override the get_exported() method for special exporting logic.
    # Override the get_value() method for specific calculations on my value or raise special BFExceptions
    # Override the _format_value() method for specific formatting
    # Override the get_res() method to send informative msgs or raise special BFExceptions
    # The get_res() method is also used to draw the same messages and exceptions on the UI panel

    def get_value(self, context, element) -> "any or None":
        """Get my Blender property value for element. On error raise BFException."""
        return getattr(element, self.bpy_idname or str(), None) # None is not accepted as attribute name, replaced with str()
        
    def _format_value(self, context, element, value) -> "str or None":
        """Format value in FDS notation for me. On error raise BFException."""
        # Expected output:
        #   ID='example' or PI=3.14 or COLOR=3,4,5
        # Custom parameters (no self.fds_label) needs special treatment in fds.props or fds.props_geometry
        if value is None: return None
        # If value is not an iterable, then put it in a tuple
        if not isiterable(value): values = tuple((value,)) 
        else: values = value
        # Check first element of the iterable and choose formatting
        if   isinstance(values[0], bool):  value = ",".join(value and ".TRUE." or ".FALSE." for value in values)
        elif isinstance(values[0], int):   value = ",".join(str(value) for value in values)
        elif isinstance(values[0], float): value = ",".join("{:.{}f}".format(value, self.precision) for value in values)
        else: value = ",".join("'{}'".format(value) for value in values)
        return "=".join((self.fds_label, value))

    def get_res(self, context, element, ui=False) -> "BFResult or None":
        """Get BFResult. On error raise BFException."""
        if DEBUG: print("BFDS: BFProp.get_res:", self.idname) 
        # Init
        if not self.get_exported(context, element): return None
        res = BFResult(
            sender=self,
            value = DEBUG and "! Debug value from BFProp.get_my_res of '{}'\n".format(self.idname) or None, 
            msg = DEBUG and "Debug message from BFProp.get_my_res of '{}'".format(self.idname) or None, 
        )
        value = self.get_value(context, element)
        # Format value and return
        if ui: return res # If ui, do not format value
        res.value = self._format_value(context, element, value)
        return res

    # Import

    def set_value(self, context, element, value):
        """Set my Blender property value for element. On error raise BFException.
        Value is any type of data compatible with bpy_prop
        Eg: "String", (0.2,3.4,1.2), ...
        """
        try: setattr(element, self.bpy_idname, value)
        except: raise BFException(
            sender = self,
            msg = "Error setting '{}' to '{}.{}'".format(value, element.name, str(self.bpy_idname)),
        )

    def from_fds(self, context, element, value):
        """Set my value from value in FDS notation for element. On error raise BFException.
        Value is any type of data compatible with bpy_prop
        Eg: "String", (0.2,3.4,1.2), ...
        """
        if DEBUG: print("BFDS: BFProp.from_fds:", self.idname, element.name, value) 
        self.set_exported(context, element, True)
        self.set_value(context, element, value)

### Blender group of variables or panel <-> BFNamelist <-> FDS namelist

class BFNamelist(BFCommon):
    """BlenderFDS namelist, interface between a Blender object and an FDS namelist. See BFCommon."""
    bf_list = BFList() # contains all instances of this class

    def __init__(self, idname, label=None, description=None, enum_id=0, flags=0, \
        fds_label=None, bf_props=None, bf_prop_export=None, bf_prop_custom=None, bf_other=None, \
        bpy_type=None):
        # Parent class, partially use its features
        BFCommon.__init__(self, idname=idname, label=label, description=description, enum_id=enum_id, flags=flags, \
            fds_label=fds_label, bf_props=bf_props, bf_prop_export=bf_prop_export, bf_prop_custom=bf_prop_custom, bf_other=bf_other, \
            bpy_type=bpy_type)

    # UI: draw panel (me, self.bf_prop_export, self.bf_props, self.bf_prop_custom)
    # Override methods for custom panel
    
    def draw_header(self, context, element, layout):
        """Draw Blender panel header."""
        if self.bf_prop_export: layout.prop(element, self.bf_prop_export.bpy_idname, text="")
        if self.description: return "BlenderFDS {} ({})".format(self.label, self.description)
        return "BlenderFDS {}".format(self.label)
    
    def _get_layout(self, context, element, layout) -> "layout":
        """If self has a bf_prop_export, prepare Blender panel layout."""
        layout.active = bool(self.has_active_ui(context, element)) # bool( protects from None
        return layout

    def _draw_body(self, context, element, layout):
        """Draw panel body."""
        for bf_prop in self.bf_props or tuple(): bf_prop.draw(context, element, layout)
        if self.bf_prop_custom: self.bf_prop_custom.draw(context, element, layout)

    def _draw_extra(self, context, element, layout):
        """Draw extra customized widgets."""
        pass

    def _draw_messages(self, context, element, layout):
        """Draw messages and exceptions."""
        try: res = self.get_my_res(context, element, ui=True)
        except BFException as err: err.draw(layout, box=True)
        else: res and res.draw(layout, box=True) # check res existence before...    

    def draw(self, context, element, layout):
        """Draw Blender panel."""
        if self.has_ui(context, element):
            layout = self._get_layout(context, element, layout)
            self._draw_messages(context, element, layout)
            self._draw_body(context, element, layout)
            self._draw_extra(context, element, layout)

    # Export (me and children)
    # Override the get_exported() method for special exporting logic.
    # Override the _format() method for specific formatting
    # Override the get_my_res() method to send informative msgs, special values or raise special BFExceptions
    # The get_my_res() method is also used to draw the same messages and exceptions on the UI panel
    # Override the get_res() method to send informative msgs or raise special BFExceptions

    # Single ID is sent from bf_id BFProp,
    # multiple ID is embedded in multivalues coming from geometric BFProp

    def _format(self, context, element, my_res, children_res) -> "str or None":
        """Format to FDS notation. On error raise BFException."""
        # Expected output:
        #   ! OBST: Message                 < my_res.labels
        #   ! OBST: ID: Message               + children labels (from self.bf_props)
        #   ! OBST: XB: Message
        #   &OBST ID='example' XB=... /\n   < body < c_multivalue[0] + c_value
        #   &OBST ID='example' XB=... /\n            c_multivalue[1] + c_value
        #   &XXXX P1=... /\n                < my_res.value
        # Append children messages to my messages (children are self.bf_props)
        my_res.msgs.extend(label for child_res in children_res for label in child_res.labels)
        # Search and extract the first (and should be only) multivalue from children values     
        child_multivalues = None
        for child_res in children_res:
            if isiterable(child_res.value):
                # Set the multivalue and remove multivalue child_res from single value children_res
                child_multivalues = child_res.value
                children_res.remove(child_res)
                # Each multivalue contains its multi ID, then remove ordinary single ID sent by "bf_id"
                children_res.remove(children_res["bf_id"])
                break
        # Set fds_label: use self.fds_label or children_res[0].value
        # When using first children value, remove child from BFList 
        if self.fds_label: fds_label = self.fds_label
        else: fds_label = children_res.pop(0).value
        # Join children values
        children_value = " ".join(child_res.value for child_res in children_res if child_res.value)
        # Build body: When multivalue exists, ID is embedded into each child_multivalue;
        # else ID is embedded into children_value
        if child_multivalues: body = "".join("&{} {} {} /\n".format(
            fds_label, child_multivalue, children_value,
            ) for child_multivalue in child_multivalues
        )
        else: body = "&{} {} /\n".format(fds_label, children_value)
        # Return
        return "".join((
            fds_format.to_comment(my_res.labels),
            body,
            my_res.value or str(), # my_res.value could be None
        ))

    # Import

    def from_fds(self, context, element, value) -> "None":
        """Translate and set FDS value to my value for element. On error raise BFException (trapped by parent from_fds method).
        Value is: ((fds_label, value, original string), ...)
        Eg: (("ID", "example", "ID='example'"), ("XB", (1., 2., 3., 4., 5., 6.,), "XB=..."), ("SURF_ID", "material"),...)
        """
        if DEBUG: print("BFDS: BFNamelist.from_fds:", self.idname, element.name, "\n", value) 
        # Set myself
        self.set_exported(context, element, True)
        if "draw_type" in (self.bf_other or tuple()): element.draw_type = self.bf_other["draw_type"]
        if "hide" in (self.bf_other or tuple()): element.hide = self.bf_other["hide"]
        # For each token set corresponding descendant or custom_value
        err_msgs, custom_value = list(), list()
        for token in value or tuple():
            # Unpack
            fds_original, fds_label, fds_value = token
            # Search the corresponding descendant by fds_label and try to set its value
            is_imported = False
            for descendant in self.descendants:
                if descendant.fds_label == fds_label:            
                    # fds_label corresponding
                    try: descendant.from_fds(context, element, fds_value)
                    except BFException as descendant_err:
                        err_msgs.extend(descendant_err.labels) # The descendant sends exceptions, take note. Labels attach sender name to msgs.
                    else: is_imported = True # succesful import
                    break # end the search for descendants
            # Check if import was succesful
            if not is_imported:
                # The token could not be imported because of a raised exception or corresponding descendant not found,
                # so pile the original token into custom_value.
                custom_value.append(fds_original)
                if INFO or DEBUG: print("BFDS: BFNamelist.from_fds: to custom param:\n ", fds_original) 
        # Set final bf_prop_custom. If no self.bf_prop_custom, then the saved fds_origins are lost
        if custom_value and self.bf_prop_custom:
            self.bf_prop_custom.set_value(context, element, " ".join(custom_value))
        # Raise all piled exceptions to parent
        if err_msgs: raise BFException(sender=self, msgs=err_msgs)

### Blender Object <-> BFObject <-> FDS geometric entity (eg. OBST, VENT, HOLE...)

class BFObject(BFCommon):
    """Extend object, and material"""

    # bpy.types do have "name", not "idname"
    def _get_idname(self) -> "str":
        """Generate idname from self.name."""
        return self.name

    idname = property(_get_idname)

    # Export (me and children)
    # Override the _format() method for specific formatting
    # Override the get_my_res() method to send informative msgs, special values or raise special BFExceptions
    # The get_my_res() method is also used to draw the same messages and exceptions on the UI panel
    # Override the get_res() method to send informative msgs or raise special BFExceptions

    def _get_children(self) -> "BFList of BFNamelist, never None":
        """Get children (self.bf_namelist!) related to self."""
        # This is an element that has one BFNamelist: Object, Material
        return BFList((BFNamelist.bf_list[self.bf_namelist],))

    children = property(_get_children)

    def get_exported(self, context, element=None) -> "bool": # 'element' kept for polymorphism
        """Return True if self is exported to FDS."""
        return True

    def get_res(self, context, element=None, ui=False) -> "BFResult or None": # 'element' kept for polymorphism
        """Get full BFResult (children and mine). On error raise BFException."""
        if INFO or DEBUG: print("BFDS: BFObject.get_res:", self.idname)
        return BFCommon.get_res(self, context, self, ui) # 'self' replaces 'element' as reference
    
    def to_fds(self, context=None) -> "str or None":
        """Export me in FDS notation, on error raise BFException."""
        if INFO or DEBUG: print("BFDS: BFObject.to_fds:", self.idname)
        if not context: context = bpy.context
        res = self.get_res(context, self)
        if res: return res.value

def update_ob_bf_namelist(self, context):
    """Update function for object.bf_namelist bpy_prop"""
    # Del all tmp_objects, if self has one
    if self.bf_has_tmp: geometry.del_all_tmp_objects(context)
    # Set all geometries to NONE, as different namelists have different geometric possibilities
    self.bf_xb, self.bf_xyz, self.bf_pb = "NONE", "NONE", "NONE"

# System properties

bpy.types.Object.bf_namelist = bpy.props.EnumProperty(  # link to related BFNamelist
    name="Namelist", description="Type of FDS namelist",
    items=(("bf_obst","OBST","OBST",1000),), default="bf_obst", update=update_ob_bf_namelist) # items are updated later

bpy.types.Object.bf_is_tmp = bpy.props.BoolProperty(
    name="Is Tmp", description="Set if this element is tmp", default=False)

bpy.types.Object.bf_has_tmp = bpy.props.BoolProperty(
    name="Has Tmp", description="Set if this element has a visible tmp element companion", default=False)

# Added methods
    
bpy.types.Object.idname = BFObject.idname
bpy.types.Object.get_exported = BFObject.get_exported
bpy.types.Object.children = BFObject.children
bpy.types.Object.descendants = BFObject.descendants
bpy.types.Object._format = BFObject._format
bpy.types.Object.get_children_res = BFObject.get_children_res
bpy.types.Object.get_my_res = BFObject.get_my_res
bpy.types.Object.get_res = BFObject.get_res
bpy.types.Object.to_fds = BFObject.to_fds

### Blender Material <-> BFMaterial <-> FDS SURF

BFMaterial = BFObject

# System properties

bpy.types.Material.bf_namelist = bpy.props.EnumProperty( # link to related BFNamelist
    name="Namelist", description="Type of FDS namelist",
    items=(("bf_surf","SURF","SURF",2000),), default="bf_surf") # items are updated later

# Added methods

bpy.types.Material.idname = BFMaterial.idname
bpy.types.Material.get_exported = BFMaterial.get_exported
bpy.types.Material.children = BFMaterial.children
bpy.types.Material.descendants = BFMaterial.descendants
bpy.types.Material._format = BFMaterial._format
bpy.types.Material.get_children_res = BFMaterial.get_children_res
bpy.types.Material.get_my_res = BFMaterial.get_my_res
bpy.types.Material.get_res = BFMaterial.get_res
bpy.types.Material.to_fds = BFMaterial.to_fds

### Blender Scene <-> BFScene <-> FDS Case

class BFScene(BFObject):
    """Extend bpy.types.scene"""

    # Export (me and children)
    # Override the _format() method for specific formatting
    # Override the get_my_res() method to send informative msgs, special values or raise special BFExceptions
    # The get_my_res() method is also used to draw the same messages and exceptions on the UI panel
    # Override the get_res() method to send informative msgs or raise special BFExceptions

    def _get_children(self) -> "BFList of Blender elements, never None":
        """Get children: bf_namelists related to Scene, objects in Scene, materials in Scene."""
        # Init
        children = list()
        context = bpy.context
        # Get my bf_namelists
        children.extend([bf_namelist for bf_namelist in BFNamelist.bf_list if bf_namelist.bpy_type == bpy.types.Scene])
        # Get materials (export all not only referenced materials as before)
        mas = list(ma for ma in bpy.data.materials \
            if ma.bf_namelist_export and \
            (ma.name not in fds_surf.predefined))
        mas.sort(key=lambda k:k.name) # Alphabetic order by element name
        children.extend(mas)
        # Get objects
        obs = list(ob for ob in context.scene.objects \
            if ob.type == "MESH" and ob.bf_namelist_export)
        obs.sort(key=lambda k:k.name) # Alphabetic order by element name
        children.extend(obs)
        # Return
        return BFList(children)

    children = property(_get_children)

    def get_my_res(self, context, element, ui=False) -> "BFResult or None":
        """Get my BFResult. On error raise BFException."""
        if DEBUG: print("BFDS: BFScene.get_my_res:", self.idname, element)
        return BFResult(
            sender = self,
            value = "&TAIL /\n".format(self.idname), # closing namelist
            msgs = (
                "Generated by BlenderFDS {} on Blender {}".format(
                    ".".join(str(x) for x in sys.modules.get("blenderfds").bl_info["version"]),
                    bpy.app.version_string
                ),
                "File: {}".format(bpy.data.filepath),
                "Time: {}".format(time.strftime("%a, %d %b %Y %H:%M:%S", time.localtime())),
            ),
        )

    # Import

    def from_fds(self, context, value=None, progress=False) -> "None":
        """Import a text in FDS notation into self. On error raise BFException.
        Value is any text in good FDS notation.
        """
        if INFO or DEBUG: print("BFDS: BFScene.from_fds:", self.idname, "\n", value) 
        # Init
        from_fds_error = False
        # Progress
        if progress:
            wm = context.window_manager
            wm.progress_begin(0, 100)
        # Create new HEAD custom text
        self.bf_head_custom_text = "Imported text"
        bpy.data.texts.new(self.bf_head_custom_text)
        custom_text = bpy.data.texts[self.bf_head_custom_text]
        # Try to tokenize value
        try: tokens = fds_to_py.tokenize(value)
        except Exception as err:
            tokens, from_fds_error = list(), True
            custom_text.write(str(err))
        # Prepare progress for namelists import
        if progress: wm.progress_update(10)
        index_max = len(tokens)
        # Create elements, set their namelists, import parameters
        for index, token in enumerate(tokens):
            # Update progress
            if progress: wm.progress_update(int(index/index_max))
            # Unpack token
            fds_original, fds_label, fds_value = token
            # Search corresponding bf_namelist by name and create related new object
            is_imported = False
            for bf_namelist in BFNamelist.bf_list:
                if bf_namelist.fds_label == fds_label:
                    # Try anticipate element name from ID
                    name = dict((prop[0], prop[1]) for prop in fds_value).get("ID", False)
                    # Namelist found, create or get element depending on the type: Scene, Object, Material
                    if bf_namelist.bpy_type == bpy.types.Scene:
                        element = self
                    elif bf_namelist.bpy_type == bpy.types.Object:
                        if name: element = geometry.get_object(context, name=name) # Try to get existing object
                        else:    element = geometry.get_new_object(context, name="new {}".format(fds_label))
                        element.bf_namelist = bf_namelist.idname # link to found namelist
                    elif bf_namelist.bpy_type == bpy.types.Material:
                        if name: element = geometry.get_material(name=name) # Try to get existing
                        else:    element = geometry.get_material(name="new {}".format(fds_label))
                        element.bf_namelist = "bf_surf" # link to generic SURF namelist
                        element.use_fake_user = True # Blender saves it even if it has no users
                    else: raise ValueError("BFDS: BFScene.from_fds: Unrecognized namelist type '{}'".format(bf_namelist.idname))
                    # Element namelist is still empty, try to call its from_fds() and set its parameters
                    try: bf_namelist.from_fds(context, element, fds_value)
                    except BFException as child_err:
                        from_fds_error = True
                        # Write error from bf_namelist to custom_text
                        custom_text.write("".join(("! ERROR: {}\n".format(msg) for msg in child_err.labels)))
                        # Delete unfinished element, but not myself if element is the scene
                        if bf_namelist.bpy_type == bpy.types.Object:
                            context.scene.objects.unlink(element)
                            bpy.data.objects.remove(element)
                        elif bf_namelist.bpy_type == bpy.types.Material:
                            bpy.data.materials.remove(element)
                    else:
                        if INFO or DEBUG: print("BFDS: BFScene.from_fds: imported:\n", fds_original) 
                        is_imported = True # all ok, object created and parameters set
                    break # bf_namelist already found, stop searching by exiting loop
            # If after searching, namelist was not found or parameters could not be set
            if not is_imported:
                # Write original item to custom_text
                custom_text.write(fds_original + "\n")
                if INFO or DEBUG: print("BFDS: BFScene.from_fds: to custom text:\n", fds_original) 
        # If any exception was raised, inform the parent
        if progress: wm.progress_end()
        if from_fds_error: raise BFException(sender=self)

# System properties: None

# Add methods

bpy.types.Scene.idname = BFScene.idname
bpy.types.Scene.get_exported = BFScene.get_exported
bpy.types.Scene.children = BFScene.children
bpy.types.Scene.descendants = BFScene.descendants
bpy.types.Scene._format = BFScene._format
bpy.types.Scene.get_children_res = BFScene.get_children_res
bpy.types.Scene.get_my_res = BFScene.get_my_res
bpy.types.Scene.get_res = BFScene.get_res
bpy.types.Scene.to_fds = BFScene.to_fds
bpy.types.Scene.from_fds = BFScene.from_fds
