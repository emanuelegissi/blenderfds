"""BlenderFDS, tokenize FDS file in a readable notation"""

import re
#from blenderfds.config import *
DEBUG = True

patterns = dict()

def _extract(value, regex):
    """Extract regex from value"""
    start = 0
    results = list()
    pattern = re.compile(regex[0], regex[1])
    while True:
        m = pattern.match(value, start)
        if not m: break
        results.append(list(m.groups()))
        start = m.end(0)
    if DEBUG:
        print("BFDS: fds_to_py._extract:")
        for result in results: print(", ".join("<{}>".format(item) for item in result))
    return results

def tokenize(fds_file):

    # Extract namelists
    regex = r"""
        .*?     # zero or more chars of any type (not greedy) (re.DOTALL) 
            (?P<namelist>   # namelist, group "namelist"
                ^&                              # ampersand after newline (re.MULTILINE)
                (?P<label>[A-Z0-9_]{4})         # namelist label, 4 chars, group "fds_label"
                [,\s]+                          # followed by one or more separators of any kind
                (?P<params>                     # namelist parameters, group "fds_params"
                    (?: '[^']*?' | "[^"]*?" | [^'"] )*?     # namelist params; protect strings, any char allowed
                )
            [,\s]*          # followed by zero or more separators of any kind
            /               # closing slash, anything outside &.../ is a comment and is ignored
            )    
    """, re.VERBOSE | re.MULTILINE | re.DOTALL
    namelists = _extract(fds_file, regex)
    
    # Extract parameters
    regex = r"""
        [,\s]*          # zero or more separators
        (?P<original>
        (?P<label>      # the parameter label (group "label"). Could be: ID or MATL_ID(1:2,1)
            [A-Z0-9_]+      # First part, as in MATL_ID
            (?:\([0-9:,]+\))? # Second optional part, as in (1:2,1)
        )
        [\s]*           # followed by zero or more spaces
        =               # an equal sign
        [\s]*           # followed by zero or more spaces
        (?P<value> '[^']*?' | "[^"]*?" | [^'"]+? )  # the parameter value (group "value"):
                                                    # a 'string' (not greedy), or a "string" (not greedy),
                                                    # or any number of chars (this protects '=' chars inside strings)
        (?=             # stop the previous value match when it is followed by
            [,\s]+          # one or more separators
            [A-Z0-9_]+      # another parameter label (same definition as before)
            (?:\([0-9:,]+\))? # 
            [\s]*           # zero or more spaces
            =               # an equal sign
            |               # or
            $               # the end of the string
        )
        )
    """, re.VERBOSE | re.MULTILINE | re.DOTALL
    for namelist in namelists:
        namelist[2] = _extract(namelist[2], regex)
    return namelists

if __name__ == "__main__":
    # Get fds_file
    import sys
    if not sys.argv: exit()
    print("BFDS tokenizing:", sys.argv[1])
    with open(sys.argv[1], 'r') as f:
        fds_file = f.read()
    # Tokenize it
    results = tokenize(fds_file)
    print("--------------")
    for result in results: print(["<{}>".format(item) for item in result])
    
exit(0)

###

char = r"."
zero_or_more_not_greedy = r"*?"
separator = r"[,\s]"
namelist_label = r"[A-Z0-9_]{4}"
params = r"""( '[^']*?' | "[^"]*?" | [^'"] )*?"""


regex = r"""
    .*?     # zero or more chars of any type (not greedy) (re.DOTALL) 
    (?P<namelist>   # namelist, group "namelist"
        ^&                              # ampersand after newline (re.MULTILINE)
        (?P<label>[A-Z0-9_]{4})         # namelist label, 4 chars, group "fds_label"
        [,\s]+                          # followed by one or more separators of any kind
        (?P<params>                     # namelist parameters, group "fds_params"
            (?: '[^']*?' | "[^"]*?" | [^'"] )*?     # namelist params; protect strings, any char allowed
        )
    [,\s]*          # followed by zero or more separators of any kind
    /               # closing slash, anything outside &.../ is a comment and is ignored
    )    
""", re.VERBOSE | re.MULTILINE | re.DOTALL

patterns["namelist"] = re.compile(regex, re.VERBOSE | re.MULTILINE | re.DOTALL)




def _extract_namelists(value):
    """Extract list of namelists from string"""
    # Input: "&OBST ID='example1' XB=1,2,3,4,5,6 /\n&VENT ID='example2' XB=1,2,3,4,5,6 /""
    # Output: [("&OBST ID='example1' XB=1,2,3,4,5,6 /"), "&VENT ID='example2' XB=1,2,3,4,5,6 /", ...]
    start = 0
    namelists = list()
    while True:
        m = patterns["namelist"].match(value, start)
        if not m: break
        namelists.append((m.group("namelist"), m.group("fds_label"), m.group("fds_params"), ))
        start = m.end(0)
    return namelists

###

regex = r"""
    [\s]*           # zero or more spaces of any kind
    =               # an equal sign
    [\s]*           # zero or more spaces of any kind
"""
patterns["equal sign"] = re.compile(regex, re.VERBOSE | re.MULTILINE | re.DOTALL)

regex = r"""
    [\s]*           # zero or more spaces of any kind
    ,               # a comma
    [\s]*           # zero or more spaces of any kind
"""
patterns["comma"] = re.compile(regex, re.VERBOSE | re.MULTILINE | re.DOTALL)

regex = r"""
    [\s]+           # one or more spaces of any kind
"""
patterns["more spaces"] = re.compile(regex, re.VERBOSE | re.MULTILINE | re.DOTALL)

regex = r"""
    &                       # ampersand at start
    (?P<label>[A-Z0-9_]{4}) # namelist label, 4 chars, group "label"
    [,\s]+                  # followed by one or more separators of any kind
    (?P<parameters>.*?)     # parameters
    [,\s]*                  # followed by zero or more separators of any kind
    /                       # closing slash
"""
patterns["label parameters"] = re.compile(regex, re.VERBOSE | re.MULTILINE | re.DOTALL)

def _extract_label_and_parameters(namelists):
    # Input:  ("&OBST  ID = 'example1' XB = 1,  2,\t 3, /n 4, 5, 6 /", ...)
    # Output: [["OBST", "ID='example1' XB=1,2,3,4,5,6", "&OBST ID='example1' XB=1,2,3,4,5,6 /"], ...]
    tokens = list()
    for namelist in namelists:
        namelist = patterns["equal sign"].sub("=", namelist) # clean equal signs
        namelist = patterns["comma"].sub(",", namelist) # clean commas
        namelist = patterns["more spaces"].sub(" ", namelist) # clean multiple spaces of any kind
        m = patterns["label parameters"].match(namelist) # extract label and parameters
        if m: tokens.append([m.group("label"), m.group("parameters"), namelist])
        else: raise ValueError("BFDS: fds_to_py: Malformed namelist:\n {}...".format(namelist[:80]))
    return tokens

###

regex = r""" # Get one parameter:
    [,\s]*          # zero or more separators
    (?P<original>
    (?P<label>      # the parameter label (group "label"). Could be: ID or MATL_ID(1:2,1)
        [A-Z0-9_]+      # First part, as in MATL_ID
        (\([0-9:,]+\))? # Second optional part, as in (1:2,1)
    )
    [\s]*           # followed by zero or more spaces
    =               # an equal sign
    [\s]*           # followed by zero or more spaces
    (?P<value> '.*?' | ".*?" | .*? ) # the parameter value (group "value"):
                                     # a 'string' (not greedy), or a "string" (not greedy),
                                     # or any number of chars (this protects '=' chars inside strings)
    (?=             # stop the previous value match when it is followed by
        [,\s]+          # one or more separators
        [A-Z0-9_]+      # another parameter label (same definition as before)
        (\([0-9:,]+\))? # 
        [\s]*           # zero or more spaces
        =               # an equal sign
        |               # or
        $               # the end of the string
    )
    )
"""

patterns["single parameter"] = re.compile(regex, re.VERBOSE | re.DOTALL)

def _extract_parameters(parameters_group):
    # Input:  "ID='example1' XB=1,2,3,4,5,6"
    # Output: [("ID", "example1", "ID='example1'"), ("XB", (1,2,3,4,5,6), "XB=1,2,3,4,5,6")]
    start = 0
    parameters = list()
    while True:
        # Get one parameter
        m = patterns["single parameter"].match(parameters_group, start)
        if not m: break # no parameter left
        # Translate value from FDS to Py
        value = m.group("value")
        if   value == ".TRUE.":  value = True
        elif value == ".FALSE.": value = False
        else: 
            try: value = eval(value)
            except: raise ValueError("BFDS: fds_to_py: Malformed parameter:\n {}...".format(parameters_group[start:80]))
        # Append good parameter and set cursor
        parameters.append((m.group("label"), value, m.group("original")))
        start = m.end("value")
    return parameters

###

def tokenize(value):
    """Tokenize an FDS input file."""
    namelists = _extract_namelists(value)
    if DEBUG:
        print("BFDS: fds_to_py.tokenize: namelists:")
        for namelist in namelists: print("n: <{0[0]}> <{0[1]}>\n   <{0[2]}>".format(namelist))
    return None
    tokens = _extract_label_and_parameters(namelists)
    for token in tokens: token[1] = _extract_parameters(token[1])
    return tokens

###

if __name__ == "__main__":
    import sys
    if not sys.argv: exit()
    print("BFDS tokenizing:", sys.argv[1])
    with open(sys.argv[1], 'r') as f:
        fds_file = f.read()
    _extract(fds_file, patterns["namelist"])    
        
    #fds_tokens = tokenize(fds_file)
    #for token in fds_tokens: print("t>", token)
